% P = U*X
% P = d*n matrix, U = d*k matrix, X = k*n matrix

% Setting Constants
epsilon = 1;

% Importing data and converting to the matrix form
P = csvread('ionosphere_mod.csv');
P = P';
[d n] = size(P);

% Computing columns of U (greedy algorithm)
r = randi([1, n], 1, 1);
U = P(:, r);

max_dist = -Inf;
far_point = zeros(d, 1);
i = 0;
while true
    max_dist = distance_chull(U, P(:, 1), 100);
    far_point = P(:, 1);
    for j = 2:n
        temp_dist = distance_chull(U, P(:, j), 100);
        if temp_dist > max_dist
            max_dist = temp_dist;
            far_point = P(:, j);
        end
    end
    if max_dist <= epsilon
        break
    else
        U = [U, far_point];
    end
    i = i + 1;
    fprintf('End of iteration:%d\n', i);
end

%fprintf('k:%d\n', size(U, 2));
    
% Evaluate X using matrix multiplication
X = (U'*U)\(U'*P);

% Cost (Frobenius norm) ||P - U*X||^2 and Sparsity
C = norm((P - U*X), 'fro');

% Output
fprintf('No. of points(n): %d\t', n);
fprintf('No. of dimensions(d): %d\n', d);
fprintf('No. of clusters(k): %d\n', size(U, 2));
fprintf('Cost ||P - UX||: %3.3f\n', C);